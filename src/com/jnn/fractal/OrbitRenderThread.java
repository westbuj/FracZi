package com.jnn.fractal;

import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import com.jnn.expressions.Expression;import com.jnn.expressions.MathOperand;import com.jnn.util.ANR;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Rect;import android.widget.Toast;





public class OrbitRenderThread extends Thread implements Runnable {
		int sX = 0;	int sY = 0;	int tStart_its = 0;	double tStart_inf = 0;		public int cCount,newColor, startIts=0;	public static   double K1;	public static double tR;	public static double tG;	public static double tB;	  		int r,g,b;	int r2,g2,b2;	double cFracX,cFracY;		public static int RedFromCYMK=0;	public static int GreenFromCYMK=0;	public static int BlueFromCYMK=0;	public int tColor;		public float[] hsv = new float[]{0f,0f,0f,0f};
	public static boolean runRenderThread=true;
	static boolean renderingStopped=false;	double startInf = Double.MAX_VALUE;	//public RenderJob rj;
		MathOperand op = null;	MathOperand op1 = null;	MathOperand op2 = null;	MathOperand op3 = null;	MathOperand op4 = null;//	Expression iExp = null;		public OrbitRenderThread(RenderJob iRj){				MainActivity.rj=iRj;			}		public static void averageImage(int[] image, int w, int h, int radius, double weight, int passes)	{		int denom =0;		int totalR =0;		int totalG =0;		int totalB =0; 				int x2;		int y2;		for (int k=0;k<passes;k++)		for (int x=0;x<w;x++)			for (int y=0;y<h;y++){								denom =0;				totalR =0;				totalG =0;				totalB =0;								for (int j= -1 * radius;j< radius;j++)					for (int i= -1 * radius;i< radius;i++)				{						x2 =  x + j;						y2 = y + i ;												if (x2 > 0 && x2 < w && y2 > 0 && y2 < h )						{							if (j != 0 && i != 0)							{							denom += 1;							totalR += Color.red(image[x2 + (y2 *  w)]);							totalG += Color.green(image[x2 + (y2 *  w)]);							totalB += Color.blue(image[x2 + (y2 *  w)]);							}						}						if (MainActivity.resetRendering)							return;				}								totalR += Color.red(image[x + (y *  w)]) * weight;				totalG += Color.green(image[x + (y *  w)])* weight;;				totalB += Color.blue(image[x + (y *  w)])* weight;;								totalR = (int) (totalR/(denom + weight));				totalG = (int) (totalG/(denom + weight));				totalB = (int) (totalB/(denom + weight));								image[x + (y *  w)] = Color.rgb(totalR, totalG, totalB);						}	}	@Override
	public void run() {
		 								try {			 			op = new MathOperand('V',0,0);			MainActivity.rj.iExp = new Expression(MainActivity.rj.equation.toUpperCase());						MainActivity.rj.rExp = new Expression(MainActivity.rj.redEquation.toUpperCase());			MainActivity.rj.gExp = new Expression(MainActivity.rj.greenEquation.toUpperCase());			MainActivity.rj.bExp = new Expression(MainActivity.rj.blueEquation.toUpperCase());						MainActivity.rj.startIts_Eq = new Expression(MainActivity.rj.startIts.toUpperCase());			MainActivity.rj.startInf_Eq = new Expression(MainActivity.rj.startInfinity.toUpperCase());						MainActivity.rj.infIncExp = new Expression(MainActivity.rj.infinityIncrement.toUpperCase());						MainActivity.rj.itsIncExp = new Expression(MainActivity.rj.itsIncEquation.toUpperCase());						MainActivity.rj.cyanExp =  new Expression(MainActivity.rj.CyanEquation.toUpperCase());			MainActivity.rj.yellowExp =  new Expression(MainActivity.rj.YellowEquation.toUpperCase());			MainActivity.rj.magentaExp =  new Expression(MainActivity.rj.magentaEquation.toUpperCase());			MainActivity.rj.blackExp =  new Expression(MainActivity.rj.blackEquation.toUpperCase());						MainActivity.rj.HueExp =  new Expression(MainActivity.rj.HueEquation.toUpperCase());			MainActivity.rj.SaturationExp =  new Expression(MainActivity.rj.SaturationEquation.toUpperCase());			MainActivity.rj.LevelExp =  new Expression(MainActivity.rj.LevelEquation.toUpperCase());														/*} catch (Exception e) {			// TODO Auto-generated catch block			e.printStackTrace();		}*/																if (MainActivity.rj.resumeJob)		{			sX = (int) MainActivity.rj.currentRX;			sY = (int) MainActivity.rj.currentRY ;			tStart_its = (int) MainActivity.rj.currentMaxIts;			tStart_inf = MainActivity.rj.currentInfinity;			MainActivity.rj.resumeJob = false;					}else 		{			sX = 0;			sY = 0;			tStart_its = (int)MainActivity.rj.startIts_Eq.evaluate(null).a;			tStart_inf = MainActivity.rj.startInf_Eq.evaluate(null).a;						MainActivity.rj.resumeJob = false;					}										if (tStart_its <= 0)			tStart_its = 1;						//If progressive and seeding color		if (MainActivity.rj.progressiveFlag)			for (int x=sX;x < MainActivity.rj.w;x++)				for (int y=sY;y < MainActivity.rj.h;y++)					MainActivity.rj.imageArray[(y*MainActivity.rj.w) + x]=Color.WHITE; //COLOR SEED  			  		 				cFracX= (MainActivity.rj.x2-MainActivity.rj.x1);				cFracY= (MainActivity.rj.y2-MainActivity.rj.y1);								startIts= tStart_its;//MainActivity.rj.startIts;				startInf=tStart_inf;//MainActivity.rj.startInfinity;														MainView.renderBox.right =MainView.renderBox.left;		MainActivity.rj.currentInfinity =startInf;		MainActivity.rj.currentMaxIts=startIts; 		MainActivity.rj.updateHandler.sendEmptyMessage(0);										while (startIts < MainActivity.rj.its && startInf < MainActivity.rj.infinity)		{						for (int x=sX;x < MainActivity.rj.w;x++)				{						for (int y=sY;y < MainActivity.rj.h;y++)				 						{							sY=0;												if (MainActivity.rj.progressiveFlag)								{r=Color.red(MainActivity.rj.imageArray[(y*MainActivity.rj.w) + x]);								g=Color.green(MainActivity.rj.imageArray[(y*MainActivity.rj.w) + x]);								b=Color.blue(MainActivity.rj.imageArray[(y*MainActivity.rj.w) + x]);																						}							else{								r=0;								g=0;								b=0;							}																												cCount=0; 												MainActivity.rj.currentZa = 0;//MainActivity.rj.aSeed;//0;//seed						MainActivity.rj.currentZb = 0;//MainActivity.rj.bSeed;//0;//seed												MainActivity.rj.currentX = MainActivity.rj.x1+(x*(cFracX/MainActivity.rj.w));//seed						MainActivity.rj.currentY = MainActivity.rj.y1+(y*(cFracY/MainActivity.rj.h));//y;//seed												MainActivity.rj.currentRX = x;						MainActivity.rj.currentRY = y; 												double dist=0;						double closeA=0;						double closeB=0;																								dist = startInf;//Double.NEGATIVE_INFINITY; Math.sqrt(Math.pow(MainActivity.rj.currentZa - MainActivity.rj.aSeed,2)+ Math.pow(MainActivity.rj.currentZb - MainActivity.rj.bSeed,2));						//double lDist=dist;						MainActivity.rj.currentDist=Double.POSITIVE_INFINITY; 						while (cCount < startIts && MainActivity.rj.currentDist > startInf )						{								op = MainActivity.rj.iExp.evaluate(op);																dist = Math.sqrt(Math.pow(op.a - MainActivity.rj.aSeed,2)+ Math.pow(op.b - MainActivity.rj.bSeed,2));								if (dist < MainActivity.rj.currentDist)									{MainActivity.rj.currentDist=dist;									closeA=op.a;									closeB=op.b;										}								MainActivity.rj.currentZa=op.a;								MainActivity.rj.currentZb=op.b;									cCount++;								if (MainActivity.resetRendering || MainActivity.slowThread) 									{									if (MainActivity.resetRendering)																			return;									Thread.sleep(25);									}																						}						MainActivity.rj.currentZa=closeA;						MainActivity.rj.currentZb=closeB;												MainActivity.rj.currentIts = cCount;												//save time here (a little)						MainActivity.rj.currentInfinity =startInf;						MainActivity.rj.currentMaxIts=startIts; 																					switch (MainActivity.rj.colorMode)						{						case RenderJob.RGB_COLOR_MODE:								op = MainActivity.rj.rExp.evaluate(op); 								//r2 =(int) (255 * Math.abs(op.a));								r2 =(int) (255 * op.a);								 								op = MainActivity.rj.gExp.evaluate(op);								//g2 =(int) (255 * Math.abs(op.a));								g2 =(int) (255 * op.a);																op = MainActivity.rj.bExp.evaluate(op); 								//b2 =(int) (255 * Math.abs(op.a));								b2 =(int) (255 * op.a);						break;												case RenderJob.CYMK_COLOR_MODE:														/*Black   = minimum(1-Red,1-Green,1-Blue)						    Cyan    = (1-Red-Black)/(1-Black)						    Magenta = (1-Green-Black)/(1-Black)						    Yellow  = (1-Blue-Black)/(1-Black) */																					op1 = MainActivity.rj.cyanExp.evaluate(null);							op2 = MainActivity.rj.magentaExp.evaluate(null);							op3 = MainActivity.rj.yellowExp.evaluate(null);							op4 = MainActivity.rj.blackExp.evaluate(null);														OrbitRenderThread.RGBfromCYMK(op1.a,op2.a, op3.a,op4.a);														//r2 =(int) (255 * Math.abs(op.a));							r2 =OrbitRenderThread.RedFromCYMK;							g2 =OrbitRenderThread.GreenFromCYMK;							b2 =OrbitRenderThread.BlueFromCYMK;							 					break;											case RenderJob.HSL_COLOR_MODE:														/*Black   = minimum(1-Red,1-Green,1-Blue)						    Cyan    = (1-Red-Black)/(1-Black)						    Magenta = (1-Green-Black)/(1-Black)						    Yellow  = (1-Blue-Black)/(1-Black) */																					hsv[0] = 360f * (float) MainActivity.rj.HueExp.evaluate(null).a;							hsv[1] = (float) MainActivity.rj.SaturationExp.evaluate(null).a;							hsv[2] = (float) MainActivity.rj.LevelExp.evaluate(null).a;																												tColor = Color.HSVToColor(hsv);																												//RenderThread.RGBfromCYMK(op1.a,op2.a, op3.a,op4.a);														//r2 =(int) (255 * Math.abs(op.a));							r2 =Color.red(tColor);							g2 =Color.green(tColor);							b2 =Color.blue(tColor);							 					break;						}												if (MainActivity.rj.progressiveFlag)						{							r += (r2 * MainActivity.rj.progWeight);							g += (g2 * MainActivity.rj.progWeight);							b += (b2 * MainActivity.rj.progWeight);							r2 = (int) (r/(MainActivity.rj.progWeight + 1));							g2 = (int) (g/(MainActivity.rj.progWeight + 1));							b2 = (int) (b/(MainActivity.rj.progWeight + 1));													}												//newColor =  Color.rgb((int)(255*intensity),(int)(255*rY),(int)(255*rX));										/*r += Color.red(newColor);						g += Color.green(newColor);						b += Color.blue(newColor);												r /=3;						g /=3;						b /=3;*/																								MainActivity.rj.imageArray[(y*MainActivity.rj.w) + x]= Color.rgb(r2,g2,b2);//this.calcChaos_new(minX+(x*(cFracX/imgWidth)),minY+(y*(cFracY/imgHeight)),startInf,startIts);						if (MainActivity.resetRendering || MainActivity.slowThread) 						{						if (MainActivity.resetRendering)																return;						Thread.sleep(25);						}																																								}								MainView.renderBox.right =MainView.renderBox.left+  (int)(MainActivity.rj.w*(x / (float)MainActivity.rj.w));				//Rect src= new Rect(0,0,MainView.renderBox.right ,MainActivity.rj.h);				//Rect dst= new Rect(0,0,MainView.renderBox.right ,MainActivity.rj.h);				MainActivity.renderCanvas.drawBitmap(MainActivity.rj.imageArray, 0, MainActivity.rj.w, 0, 0, MainActivity.rj.w,MainActivity.rj.h,false, null);				MainActivity.rj.updateHandler.sendEmptyMessage(0);				//MainActivity.updateImage.sendEmptyMessage(0);			}					 											if (MainActivity.rj.averageFlag)									OrbitRenderThread.averageImage(MainActivity.rj.imageArray, MainActivity.rj.w, MainActivity.rj.h,MainActivity.rj.averageRadius,MainActivity.rj.averageWeight,MainActivity.rj.averagePasses);																			if (MainActivity.rj.saveFlag)					savePNG();													for (int j=0;j< 200;j++)				{					if (MainActivity.resetRendering)															return;					Thread.sleep(50);				}							/*	if (MainActivity.rj.target == 'S')				{					//MainView.renderBox.right =MainView.renderBox.left;					MainActivity.updateImage.sendEmptyMessage(0);				}*/																				//Bitmap pImage=Toolkit.getDefaultToolkit().createImage(rSource);				//paintI=	pImage;													op = MainActivity.rj.itsIncExp.evaluate(null);			startIts = (int) op.a;			//startIts *= 1.50;			op = MainActivity.rj.infIncExp.evaluate(null);			startInf = op.a;			sX = 0;					}				//MainActivity.rj.updateHandler.sendEmptyMessage(0);	}	 catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}	}	public static void RGBfromCYMK(double C,double M, double Y, double K){			//	final double power1 = 1.0 / 2.4;        K1 = 1.0F - K;         tR = K1*(1.0F - C);        tG = K1*(1.0F - M);        tB = K1*(1.0F - Y);                // Convert from CMYK to linear RGB.   //     float[] rgbvalue = new float[] {K1*(1.0F - C),     //                                   K1*(1.0F - M),       //                                 K1*(1.0F - Y)};/*        // Convert from linear RGB to sRGB.        for (int i = 0; i < 3; i++) {            float v = rgbvalue[i];            if (v < 0.0F) v = 0.0F;            if (v < 0.0031308F) {                rgbvalue[i] = 12.92F * v;            } else {                if (v > 1.0F) v = 1.0F;                rgbvalue[i] = (float)(1.055 * Math.pow(v, power1) - 0.055);            }        }*/     			    OrbitRenderThread.RedFromCYMK = (int) (255 * tR);    OrbitRenderThread.BlueFromCYMK = (int) (255 * tB);    OrbitRenderThread.GreenFromCYMK = (int) (255 * tG);    	return;	}public static void zoom_in(int smallX,int smallY,int bigX,int bigY){	  double dx = MainActivity.rj.x2 - MainActivity.rj.x1;	 MainActivity.rj.x2 = MainActivity.rj.x1 + (dx *(bigX/(double)MainActivity.rj.w));	 MainActivity.rj.x1 = MainActivity.rj.x1 + (dx *(smallX/(double)MainActivity.rj.w));	 	 double dY = MainActivity.rj.y2 - MainActivity.rj.y1;	 	 	 	 MainActivity.rj.y1 = MainActivity.rj.y1 +  (dY *(smallY/(double)MainActivity.rj.h));	 MainActivity.rj.y2 = MainActivity.getX2_d(MainActivity.rj.x1, MainActivity.rj.y1, MainActivity.rj.x2, MainActivity.rj.w, MainActivity.rj.h);//rj.y1 +  (screenD * (double)(rj.x2 - rj.x1));	 	 bigY = (int) MainActivity.getX2_d(smallX,smallY,bigX,MainActivity.rj.w,MainActivity.rj.h);	 	 	     	Rect src=new Rect(smallX,smallY,bigX,bigY);	Rect dst=new Rect(0,0,MainActivity.rj.w,MainActivity.rj.h);		Canvas c = new Canvas(MainActivity.tempHolder);	c.drawBitmap(MainActivity.renderHolder, src, dst, null);	MainActivity.rj.imageArray=ANR.getBitArray(MainActivity.tempHolder);	MainActivity.rawImage = MainActivity.rj.imageArray; 			//MainActivity.renderCanvas.drawBitmap(MainActivity.tempHolder, src, dst, null);	MainActivity.updateImage.sendEmptyMessage(0);	MainActivity.renderCanvas.drawBitmap(MainActivity.rj.imageArray, 0, MainActivity.rj.w, 0, 0, MainActivity.rj.w,MainActivity.rj.h,false, null);    MainActivity.mQueue.addTask(new OrbitRenderThread(MainActivity.rj));    MainActivity.slowThread =false;	}public static void center(int smallX,int smallY,int bigX,int bigY){		   	double dx = MainActivity.rj.x2 - MainActivity.rj.x1;  	 int sdX = bigX - smallX;   	 double dY = MainActivity.rj.y2 - MainActivity.rj.y1;  	int sdY = bigY - smallY;  	  	double xScale = MainActivity.rj.w / dx;  	double yScale = MainActivity.rj.h / dY;  	  	int newCenterXDev =  (int) (smallX +(sdX/2));  	int newCenterYDev =  (int) (smallY +(sdY/2));  	  	double xOffset = newCenterXDev - (MainActivity.rj.w/2);  	double yOffset = newCenterYDev - (MainActivity.rj.h/2);  	  	double XOffFrac = xOffset / xScale;  	double YOffFrac = yOffset / yScale;   	  	  	  	MainActivity.rj.x1 += XOffFrac;//newCenterX - (dx/2);  	MainActivity.rj.x2 += XOffFrac;//= newCenterX + (dx/2);  	MainActivity.rj.y1 += YOffFrac;//= newCenterY - (dY/2);  	MainActivity.rj.y2 += YOffFrac;//= newCenterY - (dY/2);   	  	  	Rect src=new Rect(0,0,MainActivity.rj.w,MainActivity.rj.h);  	  	Rect dst = new Rect((int)(-1 * xOffset) ,(int)(-1 * yOffset),(int) (MainActivity.rj.w - xOffset) ,(int) (MainActivity.rj.h - yOffset));  	  	  		Canvas c = new Canvas(MainActivity.tempHolder);	c.drawColor(Color.GRAY);	c.drawBitmap(MainActivity.renderHolder, src, dst, null);	MainActivity.rj.imageArray=ANR.getBitArray(MainActivity.tempHolder);	MainActivity.rawImage = MainActivity.rj.imageArray; 			//MainActivity.renderCanvas.drawBitmap(MainActivity.tempHolder, src, dst, null);	MainActivity.updateImage.sendEmptyMessage(0);	MainActivity.renderCanvas.drawBitmap(MainActivity.rj.imageArray, 0, MainActivity.rj.w, 0, 0, MainActivity.rj.w,MainActivity.rj.h,false, null);    MainActivity.mQueue.addTask(new OrbitRenderThread(MainActivity.rj));    MainActivity.slowThread =false;	}public static void zoom_out(int smallX,int smallY,int bigX,int bigY){	  	  	   	double dx = MainActivity.rj.x2 - MainActivity.rj.x1;  	double sdX = bigX - smallX;   	double  dY = MainActivity.rj.y2 - MainActivity.rj.y1;  	double sdY = bigY - smallY;  	  	double xScale = MainActivity.rj.w / dx;  	double yScale = MainActivity.rj.h / dY;  	  	double newCenterXDev =  (int) (smallX +(sdX/2));  	double newCenterYDev =  (int) (smallY +(sdY/2));  	  	double xOffset = newCenterXDev - (MainActivity.rj.w/2);  	double yOffset = newCenterYDev - (MainActivity.rj.h/2);  	   	  	double XOffFrac = xOffset / xScale;  	double YOffFrac = yOffset / yScale;  	   	MainActivity.rj.x1 +=  XOffFrac;//newCenterX - (dx/2);   	MainActivity.rj.x2 +=  XOffFrac;//= newCenterX + (dx/2);   	MainActivity.rj.y1 +=  YOffFrac;//= newCenterY - (dY/2);   	MainActivity.rj.y2 += YOffFrac;//= newCenterY - (dY/2);   	   	MainActivity.rj.x1 -= dx/5;   	MainActivity.rj.x2 += dx/5;   	MainActivity.rj.y1 -= dY/5;   	MainActivity.rj.y2 += dY/5;  	  	  	//src=new Rect((int)smallX,(int)smallY,(int)bigX,(int)bigY);   	   	  	  	Rect src=new Rect(0,0,MainActivity.rj.w,MainActivity.rj.h);  	 //Rect dst=new Rect(MainActivity.rj.w/2 - sdX/2 ,MainActivity.rj.h/2 - sdY/2,MainActivity.rj.w/2 + sdX/2,MainActivity.rj.h/2 + sdY/2);  	  	  	  	double left = MainActivity.rj.w / 5;  	double right = MainActivity.rj.w - MainActivity.rj.w / 5;  	  	double top = MainActivity.rj.h / 5;  	double bottom = MainActivity.rj.h - MainActivity.rj.h / 5;  	  	left -=  xOffset;  	right -= xOffset;  	  	top -=  yOffset;  	bottom -= yOffset;  	  	  	 	Rect dst = new Rect((int)left,(int)top,(int)right,(int)bottom); 	  	  		Canvas c = new Canvas(MainActivity.tempHolder);		c.drawColor(Color.GRAY);	c.drawBitmap(MainActivity.renderHolder, src, dst, null);	MainActivity.rj.imageArray=ANR.getBitArray(MainActivity.tempHolder);	MainActivity.rawImage = MainActivity.rj.imageArray; 			//MainActivity.renderCanvas.drawBitmap(MainActivity.tempHolder, src, dst, null);		MainActivity.renderCanvas.drawBitmap(MainActivity.rj.imageArray, 0, MainActivity.rj.w, 0, 0, MainActivity.rj.w,MainActivity.rj.h,false, null);	MainActivity.updateImage.sendEmptyMessage(0);    MainActivity.mQueue.addTask(new OrbitRenderThread(MainActivity.rj));    MainActivity.slowThread =false;}public static void reset(){	int w=MainActivity.rj.w;	int h=MainActivity.rj.h;		MainActivity.rj.x1= -4; 	MainActivity.rj.x2 = 4;	MainActivity.rj.y1 = -6.5;	 	MainActivity.rj.y2 = MainActivity.getX2_d(MainActivity.rj.x1, MainActivity.rj.y1, MainActivity.rj.x2, MainActivity.rj.w,MainActivity.rj.h);	  	 MainActivity.mQueue.addTask(new OrbitRenderThread(MainActivity.rj));	 MainActivity.slowThread =false;}public static void savePNG(){								ANR.setupStorage("fraczi");	File root = new File(ANR.appStoragePath);		SimpleDateFormat formatter = new SimpleDateFormat("MM_dd_yyyy_HH_mm_ss");	Date now = new Date();	String fileName = "fZ_"+formatter.format(now) + ".png";		if (ANR.isFile(fileName))	{ int c=1;		fileName = "fZ_"+formatter.format(now)+"_"+Integer.toString(c) + ".png";		while (ANR.isFile(fileName))			c++;	}		File gpxfile = new File(root,fileName);	gpxfile.toURI().toASCIIString();		try {		FileOutputStream outStream = new FileOutputStream(gpxfile);		MainActivity.renderHolder.compress(Bitmap.CompressFormat.PNG, 100, outStream);		 	 		outStream.flush();		outStream.close();	//	Log.d("done", "done");	} catch (FileNotFoundException e) {		e.printStackTrace();		return;	} catch (IOException e) {		e.printStackTrace();		return;	}		 MainActivity.showMessage("File saved - \n"+gpxfile.getName());	//Toast.makeText(this.mContext,"File saved as "+ fileName+".", Toast.LENGTH_LONG).show();																				}
}